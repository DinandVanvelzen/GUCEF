/*
 *  ProjectGenerator: Tool to generate module/project files
 *  Copyright (C) 2002 - 2011.  Dinand Vanvelzen
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/*-------------------------------------------------------------------------//
//                                                                         //
//      INCLUDES                                                           //
//                                                                         //
//-------------------------------------------------------------------------*/

#ifndef GUCEF_CORE_LOGGING_H
#include "gucefCORE_Logging.h"
#define GUCEF_CORE_LOGGING_H
#endif /* GUCEF_CORE_LOGGING_H ? */

#ifndef GUCEF_CORE_DVCPPFILEUTILS_H
#include "dvcppfileutils.h"
#define GUCEF_CORE_DVCPPFILEUTILS_H
#endif /* GUCEF_CORE_DVCPPFILEUTILS_H ? */

#ifndef GUCEF_CORE_DVCPPSTRINGUTILS_H
#include "dvcppstringutils.h"
#define GUCEF_CORE_DVCPPSTRINGUTILS_H
#endif /* GUCEF_CORE_DVCPPSTRINGUTILS_H ? */

#include "gucefProjectGen_CArduinoCLIGenerator.h"

/*-------------------------------------------------------------------------//
//                                                                         //
//      NAMESPACE                                                          //
//                                                                         //
//-------------------------------------------------------------------------*/

namespace GUCEF {
namespace PROJECTGEN {

/*-------------------------------------------------------------------------//
//                                                                         //
//      GLOBAL VARS                                                        //
//                                                                         //
//-------------------------------------------------------------------------*/

static CORE::CString ArduinoPlatformName = "Arduino";

static const char* batchfileHeader =
    "@echo off\n"
    "SET GUCEF_THEBATCHDIR=%~dp0\n"
    "\n"
    "echo #-------------------------------------------------------------------\n"
    "echo # This file has been automatically generated by ProjectGenerator    \n"
    "echo # which is part of a build system designed for GUCEF                \n"
    "echo #     (Galaxy Unlimited Framework)                                  \n"
    "echo # For the latest info, see http://www.VanvelzenSoftware.com/        \n"
    "echo #                                                                   \n"
    "echo # The contents of this file are placed in the public domain. Feel   \n"
    "echo # free to make use of it in any way you like.                       \n"
    "echo #-------------------------------------------------------------------\n\n\n";

/*-------------------------------------------------------------------------//
//                                                                         //
//      UTILITIES                                                          //
//                                                                         //
//-------------------------------------------------------------------------*/

CORE::CString
GenerateContentForArduinoCLIWindowsSymlinkBatchfile( const TModuleInfoEntryPairVector& mergeLinks ,
                                                     const TModuleInfo& moduleInfo                ,
                                                     const CORE::CString& moduleRoot              ,
                                                     bool addGeneratorCompileTimeToOutput         ,
                                                     const CORE::CString& outputDir               )
{GUCEF_TRACE;

    CORE::CString contentPrefix = batchfileHeader;

    if ( addGeneratorCompileTimeToOutput )
    {
        contentPrefix +=
          "echo #\n"
          "echo # The project generator version used was compiled on " __TIME__ __DATE__ "\n"
          "echo #\n\n";
    }

    CORE::CString content = contentPrefix + "cmd /c mkdir \"" + CORE::RelativePath( outputDir ) + "\"\n\n";

    if ( MODULETYPE_EXECUTABLE != moduleInfo.moduleType )
    {
        CORE::CString arduinoLibPath = "\"%UserProfile%\\Documents\\Arduino\\libraries\\" + moduleInfo.name + "\"";
        GUCEF_LOG( CORE::LOGLEVEL_NORMAL, "Generating symlink script from system Arduino libraries folder to module dir for module \"" + moduleInfo.name + "\" at: " + arduinoLibPath );
        content += "\necho Setting up \""+ moduleInfo.name + "\" library symlink at " + arduinoLibPath + "\n";
        content += "cmd IF EXIST " + arduinoLibPath + " DEL /F " + arduinoLibPath + "\n";
        content += "cmd /c mklink /d /J " + arduinoLibPath + " \"" + outputDir + "\"\n";
    }
    
    CORE::CString outputSrcDir = CORE::RelativePath( CORE::CombinePath( outputDir, "src" ) );
    
    GUCEF_LOG( CORE::LOGLEVEL_NORMAL, "Generating symlinks script for all headers for module: " + moduleInfo.name );
    content += "\necho Generating symlinks for all headers for module: " + moduleInfo.name + "\n";
    
    TStringSetMap::const_iterator i = moduleInfo.includeDirs.begin();
    while ( i != moduleInfo.includeDirs.end() )
    {
        const CORE::CString& includeDir = (*i).first;
        const CORE::CString::StringSet& includes = (*i).second;
        
        CORE::CString fullAbsIncludeDirPath = CORE::RelativePath( CORE::CombinePath( moduleRoot, includeDir ) );
        
        CORE::CString::StringSet::const_iterator n = includes.begin();
        while ( n != includes.end() )
        {
            const CORE::CString& headerFilename = (*n);
            CORE::CString fullAbsHeaderPath = CORE::RelativePath( CORE::CombinePath( fullAbsIncludeDirPath, headerFilename ) );
            CORE::CString fullAbsSymLinkHeaderPath = CORE::RelativePath( CORE::CombinePath( outputSrcDir, headerFilename ) );

            content += "cmd /c IF EXIST \"" + fullAbsSymLinkHeaderPath + "\" DEL /F \"" + fullAbsSymLinkHeaderPath + "\"\n";
            content += "cmd /c mklink \"" + fullAbsSymLinkHeaderPath + "\" \"" + fullAbsHeaderPath + "\"\n";
            ++n;
        }
        ++i;
    }    

    GUCEF_LOG( CORE::LOGLEVEL_NORMAL, "Generating symlinks script for all source files for module: " + moduleInfo.name );
    content += "\necho Generating symlinks for all source files for module: " + moduleInfo.name + "\n";

    i = moduleInfo.sourceDirs.begin();
    while ( i != moduleInfo.sourceDirs.end() )
    {
        const CORE::CString& sourceDir = (*i).first;
        const CORE::CString::StringSet& sources = (*i).second;
        
        CORE::CString fullAbsSourceDirPath = CORE::RelativePath( CORE::CombinePath( moduleRoot, sourceDir ) );
        
        CORE::CString::StringSet::const_iterator n = sources.begin();
        while ( n != sources.end() )
        {
            const CORE::CString& sourceFilename = (*n);
            CORE::CString fullAbsSourcePath = CORE::RelativePath( CORE::CombinePath( fullAbsSourceDirPath, sourceFilename ) );
            CORE::CString fullAbsSymLinkSourcePath = CORE::RelativePath( CORE::CombinePath( outputSrcDir, sourceFilename ) );

            content += "cmd /c IF EXIST \"" + fullAbsSymLinkSourcePath + "\" DEL /F \"" + fullAbsSymLinkSourcePath + "\"\n";
            content += "cmd /c mklink \"" + fullAbsSymLinkSourcePath + "\" \"" + fullAbsSourcePath + "\"\n";
            ++n;
        }
        ++i;
    }

    return content;
}

/*-------------------------------------------------------------------------*/

bool
CreateArduinoCLIOutputFolderStructure( const CORE::CString& outputDir  ,
                                       CORE::CString& scriptsOutputDir ,
                                       CORE::CString& libraryOutputDir ,
                                       CORE::CString& appsOutputDir    )
{GUCEF_TRACE;

    scriptsOutputDir = CORE::RelativePath( CORE::CombinePath( outputDir, "scripts/symlinks" ) );
    if ( !CORE::CreateDirs( scriptsOutputDir ) )
    {
        GUCEF_ERROR_LOG( CORE::LOGLEVEL_NORMAL, "Failed to create Arduino output scripts directory at: " + scriptsOutputDir );
        return false;
    }
    libraryOutputDir = CORE::RelativePath( CORE::CombinePath( outputDir, "libraries" ) );
    if ( !CORE::CreateDirs( libraryOutputDir ) )
    {
        GUCEF_ERROR_LOG( CORE::LOGLEVEL_NORMAL, "Failed to create Arduino library directory at: " + libraryOutputDir );
        return false;
    }
    appsOutputDir = CORE::RelativePath( CORE::CombinePath( outputDir, "apps" ) );
    if ( !CORE::CreateDirs( appsOutputDir ) )
    {
        GUCEF_ERROR_LOG( CORE::LOGLEVEL_NORMAL, "Failed to create Arduino apps directory at: " + appsOutputDir );
        return false;
    }

    return true;
}

/*-------------------------------------------------------------------------*/

bool
IsArduinoCompilationTarget( const CModuleInfoEntry& moduleInfoEntry   ,
                            const TModuleInfo& moduleInfo             ,
                            bool onlyConsiderSpecificTags             ,
                            const CORE::CString::StringSet& validTags )
{GUCEF_TRACE;

    if ( !onlyConsiderSpecificTags ||
            ( onlyConsiderSpecificTags && IsModuleTagged( moduleInfoEntry, validTags, ArduinoPlatformName ) ) )
    {
        if ( !moduleInfo.ignoreModule                                          &&
            ( MODULETYPE_HEADER_INTEGRATE_LOCATION != moduleInfo.moduleType ) &&
            ( MODULETYPE_CODE_INTEGRATE_LOCATION != moduleInfo.moduleType )   &&
            ( MODULETYPE_REFERENCE_LIBRARY != moduleInfo.moduleType )         &&
            ( MODULETYPE_EXECUTABLE != moduleInfo.moduleType || ( MODULETYPE_EXECUTABLE == moduleInfo.moduleType && HasPlatformDefinition( moduleInfoEntry, "arduino" ) ) ) )
        {
            return true;
        }
    }
    return false;
}

/*-------------------------------------------------------------------------*/

bool
CreateArduinoCLIWindowsSymlinkBatchfiles( const TModuleInfoEntryPairVector& mergeLinks ,
                                          bool addGeneratorCompileTimeToOutput         ,
                                          const CORE::CString& outputDir               ,
                                          bool onlyConsiderSpecificTags                ,
                                          const CORE::CString::StringSet& validTags    )
{GUCEF_TRACE;

    CORE::CString scriptsOutputDir;
    CORE::CString libraryOutputDir;
    CORE::CString appsOutputDir;
    if ( !CreateArduinoCLIOutputFolderStructure( outputDir, scriptsOutputDir, libraryOutputDir, appsOutputDir ) )
        return false;    

    // first create the symlink batch files for the individual modules.
    // this for ease of maintenance purposes
    
    bool totalSuccess = true;
    TModuleInfoEntryPairVector::const_iterator i = mergeLinks.begin();
    while ( i != mergeLinks.end() )
    {
        const CModuleInfoEntry* originalModule = (*i).first;
        const TModuleInfo* mergedModule = (*i).second;

        if ( IsArduinoCompilationTarget( *originalModule          ,
                                         *mergedModule            ,
                                         onlyConsiderSpecificTags ,
                                         validTags                ) )
        {
            CORE::CString& typeBasedOutputDir = MODULETYPE_EXECUTABLE != mergedModule->moduleType ? libraryOutputDir : appsOutputDir;
            CORE::CString typeBasedModuleOutputDir = CORE::RelativePath( CORE::CombinePath( typeBasedOutputDir, mergedModule->name ) );

            CORE::CString content = GenerateContentForArduinoCLIWindowsSymlinkBatchfile( mergeLinks, *mergedModule, originalModule->rootDir, addGeneratorCompileTimeToOutput, typeBasedModuleOutputDir );

            CORE::CString moduleSymlinksFilePath = CORE::CombinePath( scriptsOutputDir, mergedModule->name + "_create_symlinks.bat" );

            GUCEF_LOG( CORE::LOGLEVEL_NORMAL, "Writing Arduino symlinks batch file for module " + mergedModule->name + " to " + moduleSymlinksFilePath );

            if ( CORE::WriteStringAsTextFile( moduleSymlinksFilePath ,
                                                content                ,
                                                true                   ,
                                                GUCEF_EOL              ) )
            {
                GUCEF_LOG( CORE::LOGLEVEL_NORMAL, "Successfully created Arduino symlinks batch file for module " + mergedModule->name + " at " + moduleSymlinksFilePath );
            }
            else
            {
                totalSuccess = false;
                GUCEF_ERROR_LOG( CORE::LOGLEVEL_NORMAL, "Failed to write Arduino symlinks batch file for module " + mergedModule->name + " at " + moduleSymlinksFilePath );
            }
        }
        ++i;
    }

    // now create an overall script which will call all the other individual module scripts

    CORE::CString contentPrefix = batchfileHeader;

    if ( addGeneratorCompileTimeToOutput )
    {
        contentPrefix +=
          "echo #\n"
          "echo # The project generator version used was compiled on " __TIME__ __DATE__ "\n"
          "echo #\n\n";
    }

    CORE::CString content = contentPrefix;
    i = mergeLinks.begin();
    while ( i != mergeLinks.end() )
    {
        const CModuleInfoEntry* originalModule = (*i).first;
        const TModuleInfo* mergedModule = (*i).second;

        if ( IsArduinoCompilationTarget( *originalModule          ,
                                         *mergedModule            ,
                                         onlyConsiderSpecificTags ,
                                         validTags                ) )
        {
            CORE::CString moduleSymlinksFile = mergedModule->name + "_create_symlinks.bat";
            content += "call .\\" + moduleSymlinksFile + GUCEF_EOL;
        }
        ++i;
    }

    CORE::CString overallModuleSymlinksFilePath = CORE::RelativePath( CORE::CombinePath( scriptsOutputDir, "create_symlinks.bat" ) );
    GUCEF_LOG( CORE::LOGLEVEL_NORMAL, "Writing overall Arduino symlinks batch file to " + overallModuleSymlinksFilePath );
    if ( CORE::WriteStringAsTextFile( overallModuleSymlinksFilePath ,
                                      content                       ,
                                      true                          ,
                                      GUCEF_EOL                     ) )
    {
        GUCEF_LOG( CORE::LOGLEVEL_NORMAL, "Successfully created overall Arduino symlinks batch file at " + overallModuleSymlinksFilePath );
    }
    else
    {
        totalSuccess = false;
        GUCEF_ERROR_LOG( CORE::LOGLEVEL_NORMAL, "Failed to write overall Arduino symlinks batch file at " + overallModuleSymlinksFilePath );
    }

    return totalSuccess;
}

/*-------------------------------------------------------------------------*/

bool
CreateArduinoCLILibraryPropertiesFiles( const TModuleInfoEntryPairVector& mergeLinks ,
                                        const CORE::CString& outputDir               ,
                                        bool onlyConsiderSpecificTags                ,
                                        const CORE::CString::StringSet& validTags    )
{GUCEF_TRACE;

    CORE::CString scriptsOutputDir;
    CORE::CString libraryOutputDir;
    CORE::CString appsOutputDir;
    if ( !CreateArduinoCLIOutputFolderStructure( outputDir, scriptsOutputDir, libraryOutputDir, appsOutputDir ) )
        return false;    
    
    bool totalSuccess = true;
    TModuleInfoEntryPairVector::const_iterator i = mergeLinks.begin();
    while ( i != mergeLinks.end() )
    {
        const CModuleInfoEntry* originalModule = (*i).first;
        const TModuleInfo* mergedModule = (*i).second;

        if ( IsArduinoCompilationTarget( *originalModule          ,
                                         *mergedModule            ,
                                         onlyConsiderSpecificTags ,
                                         validTags                ) )
        {
            // All libraries are essentially 'static' libraries for an Arduino since it all gets compiled into a singular sketch
            if ( MODULETYPE_HEADER_INCLUDE_LOCATION == mergedModule->moduleType ||
                 MODULETYPE_SHARED_LIBRARY          == mergedModule->moduleType ||       
                 MODULETYPE_STATIC_LIBRARY          == mergedModule->moduleType )
            {
                CORE::CString moduleOutputDir = CORE::RelativePath( CORE::CombinePath( libraryOutputDir, mergedModule->name ) );
                if ( CORE::CreateDirs( moduleOutputDir ) )
                {
                    CORE::CString libPropsPath = CORE::RelativePath( CORE::CombinePath( moduleOutputDir, "library.properties" ) );

                    GUCEF_LOG( CORE::LOGLEVEL_NORMAL, "Generating library.properties for module \"" + mergedModule->name + "\" at: " + libPropsPath );

                    CORE::CString content = "name=" + mergedModule->name + "\n";
                                 content += "version=" + mergedModule->metadata.semver.ToString( true, true, false ) + "\n";
                                 content += "author=" + CORE::StringSetToString( mergedModule->metadata.authors, CORE::CString::Empty, ',' ) + "\n";
                                 content += "maintainer=" + CORE::StringSetToString( mergedModule->metadata.maintainers, CORE::CString::Empty, ',' ) + "\n";
                                 content += "sentence=" + mergedModule->metadata.descriptionHeadline + "\n";
                                 content += "paragraph=" + mergedModule->metadata.descriptionDetails + "\n";
                                 content += "license=" + mergedModule->metadata.license + "\n";

                    //architectures=avr,megaavr  ?
                    //includes=src/common/include/gucef.h   ?
                
                    CORE::CString::StringSet dependencies;
                    GetModuleDependencies( *originalModule     ,
                                           ArduinoPlatformName ,
                                           dependencies        ,
                                           false               );                
                    content += "depends=" + CORE::StringSetToString( dependencies, CORE::CString::Empty, ',' ) + "\n";
                
                    if ( CORE::WriteStringAsTextFile( libPropsPath ,
                                                      content      ,
                                                      true         ,
                                                      GUCEF_EOL    ) )
                    {
                        GUCEF_LOG( CORE::LOGLEVEL_NORMAL, "Successfully created Arduino library.propertie file at " + libPropsPath );
                    }
                    else
                    {
                        totalSuccess = false;
                        GUCEF_ERROR_LOG( CORE::LOGLEVEL_NORMAL, "Failed to write Arduino library.propertie file at " + libPropsPath );
                    }
                }
                else
                {
                    GUCEF_ERROR_LOG( CORE::LOGLEVEL_NORMAL, "Failed to create Arduino library directory at " + moduleOutputDir );    
                    totalSuccess = false;
                }
            }
        }
        ++i;
    }

    return totalSuccess;
}

/*-------------------------------------------------------------------------*/

CArduinoCLIGenerator::CArduinoCLIGenerator( void )
{GUCEF_TRACE;

}

/*-------------------------------------------------------------------------*/

CArduinoCLIGenerator::~CArduinoCLIGenerator()
{GUCEF_TRACE;

}

/*-------------------------------------------------------------------------*/

bool
CArduinoCLIGenerator::GenerateProject( TProjectInfo& projectInfo            ,
                                       const CORE::CString& outputDir       ,
                                       bool addGeneratorCompileTimeToOutput ,
                                       const CORE::CValueList& params       )
{GUCEF_TRACE;

    bool treatTagsAsTargets = params.GetValueAlways( "TreatTagsAsTargets" ).AsBool( true, true );
    bool splitTargets = params.GetValueAlways( "arduinocligen:SplitTargets" ).AsBool( true, true );

    CORE::CString targetsOutputDir = params.GetValueAlways( "arduinocligen:TargetsDir" );
    if ( targetsOutputDir.IsNULLOrEmpty() )
        targetsOutputDir = outputDir;    
    targetsOutputDir = CORE::RelativePath( targetsOutputDir, true );
    if ( !CORE::CreateDirs( targetsOutputDir ) )
        GUCEF_ERROR_LOG( CORE::LOGLEVEL_IMPORTANT, "Failed to create Arduino CLI project targets output folder: " + targetsOutputDir );

    CORE::CString arduinoCLIOutputDir = params.GetValueAlways( "arduinocligen:ArduinoCLIOutputDir" ).AsString( CORE::CString::Empty, true );
    if ( arduinoCLIOutputDir.IsNULLOrEmpty() )
        arduinoCLIOutputDir = outputDir;    
    arduinoCLIOutputDir = CORE::RelativePath( arduinoCLIOutputDir, true );
    if ( !CORE::CreateDirs( arduinoCLIOutputDir ) )
        GUCEF_ERROR_LOG( CORE::LOGLEVEL_IMPORTANT, "Failed to create Arduino CLI output folder: " + arduinoCLIOutputDir );

    bool onlyConsiderSpecificTags = params.GetValueAlways( "arduinocligen:OnlyConsiderSpecificTags" ).AsBool( true, true ); 
    CORE::CString::StringSet validTags = params.GetValueAlways( "arduinocligen:ValidTags" ).AsString( CORE::CString::Empty, true ).ParseUniqueElements( ';', false );

    // Merge all the module info to give us a complete module definition for the Arduino platform
    // per module. This makes is easy for us to process as we don't care about other platforms
    TModuleInfoVector mergedInfo;
    TModuleInfoEntryPairVector mergeLinks;
    MergeAllModuleInfoForPlatform( projectInfo.modules, ArduinoPlatformName, mergedInfo, mergeLinks ); 

    CreateArduinoCLIWindowsSymlinkBatchfiles( mergeLinks, addGeneratorCompileTimeToOutput, arduinoCLIOutputDir, onlyConsiderSpecificTags, validTags );
    CreateArduinoCLILibraryPropertiesFiles( mergeLinks, arduinoCLIOutputDir, onlyConsiderSpecificTags, validTags );

    return true;
}

/*-------------------------------------------------------------------------//
//                                                                         //
//      NAMESPACE                                                          //
//                                                                         //
//-------------------------------------------------------------------------*/

}; /* namespace PROJECTGEN */
}; /* namespace GUCEF */

/*-------------------------------------------------------------------------*/
